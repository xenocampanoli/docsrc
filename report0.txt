^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc


Go source file:  docsrc.go:

1 // docsrc - Program to generate source tree documentation.
2 package main
3 
4 import (
5 	"docsrc/reports"
6 	"docsrc/treeseers"
7 	"bytes"
8 	"flag"
9 	"fmt"
10 	"os"
11 	"os/exec"
12 	"strings"
13 )
14 
15 // For now structures section (later reorganize)
16 
17 // CLConfiguration - Command Line Configurations for use by flag package.
18 // Values are parsed into this struct for passing to main for use in
19 // top level conditionals.
20 type CLConfiguration struct {
21 	report0    bool
22 	report1    bool
23 	report2    bool
24 	concurrent bool
25 	stdout     bool
26 }
27 
28 // getCLAC() - Get the command line switch values.
29 func getCLAC() *CLConfiguration {
30 	var clc CLConfiguration
31 	flag.BoolVar(&clc.report0, "report0", false, "Generate report0.txt, simple uncommented organized source listing.")
32 	flag.BoolVar(&clc.report1, "report1", false, "Generate report1.md, a relatively simple document but using all supporting files.")
33 	flag.BoolVar(&clc.report2, "report2", false, "Generate report2.html, report1 is generated, and report2 from report1.")
34 	flag.BoolVar(&clc.concurrent, "concurrent", false, "Use the concurrent version of the directory tree reader (for large trees).")
35 	flag.BoolVar(&clc.stdout, "stdout", false, "Write reports to stdout instead of report named files.")
36 	flag.Parse()
37 	// Apparently no err returned on zero value Flagset, which I think means this form.
38 	// I really did look around, and the examples are like this.
39 	return &clc
40 }
41 
42 // noReportSpecified() -  boolean function to indicate if a report is
43 // indicated on the command line so a default alternative may be chosen.
44 func (pCLC *CLConfiguration) noReportSpecified() bool {
45 	if pCLC.report0 {
46 		return false
47 	}
48 	if pCLC.report1 {
49 		return false
50 	}
51 	if pCLC.report2 {
52 		return false
53 	}
54 	return true
55 }
56 
57 // printUsage() - display USAGE statement.
58 func printUsage() {
59 	fmt.Printf("USAGE:  ./%s [argswtchs]", os.Args[0])
60 	flag.PrintDefaults()
61 }
62 
63 // Generates output to either named file, or stdout, according
64 // to the user's command line specification.
65 func outputReport(stdOut bool, cStr string, rName string) {
66 	if stdOut {
67 		fmt.Print(cStr)
68 	} else {
69 		fpo, err := os.Create(rName)
70 		if err != nil {
71 			panic(err)
72 		}
73 		// close fpo on exit and check for its returned error
74 		defer func() {
75 			if err := fpo.Close(); err != nil {
76 				panic(err)
77 			}
78 		}()
79 		_, err = fmt.Fprint(fpo, cStr)
80 		if err != nil {
81 			panic(err)
82 		}
83 	}
84 }
85 
86 // Generate report2.html from report1.md using shell markdown command.
87 func genHTMLfromMarkdown() (content string) {
88 	var out1, out2 bytes.Buffer
89 	cmd1 := exec.Command("which","markdown")
90 	cmd1.Stdout = &out1
91 	err := cmd1.Run()
92 	if err != nil {
93 		panic(err)
94 	}
95 	cmd2fs := strings.TrimSuffix(out1.String(),"\n")
96 	// The shortest path is /usr/bin/markdown, which is 17...
97 	if len(cmd2fs) > 16 {
98 		fmt.Println(cmd2fs)
99 		cmd2 := exec.Command(cmd2fs,"report1.md")
100 		cmd2.Stdout = &out2
101 		err = cmd2.Run()
102 		if err != nil {
103 			panic(err)
104 		}
105 		content = out2.String()
106 		return
107 	} else {
108 //345678901234567890123456789012345678901234567890123456789012345678901234567890
109 		nomdmsg := `
110 Cannot generate HTML output report2.html because markdown utility was not found
111 on your computer.  report1.md is at least available.  You may generate your HTML
112 file by hand after installing markdown by using the command:
113 
114 		markdown report1.md>out.html
115 
116 `
117 		fmt.Print(nomdmsg)
118 	}
119 	return
120 }
121 
122 // Generate the output report for the directory tree specified.
123 // Note that for now there is no way to specify a directory except
124 // to run the program in that directory.  This simplifies a lot of
125 // things, and reduces likelihood of messy mistakes.
126 func main() {
127 	pclc := getCLAC()
128 	pwd := os.Getenv("PWD")
129 	var pdo *treeseers.DirObject
130 	if pclc.concurrent {
131 		pdo = treeseers.ConLoadDirObject(pwd)
132 	} else {
133 		pdo = treeseers.SeqLoadDirObject(pwd)
134 	}
135 	if pclc.report0 || pclc.noReportSpecified() {
136 		content := reports.Report0(pdo, 1)
137 		outputReport(pclc.stdout, content, "report0.txt")
138 	}
139 	if pclc.report1 || pclc.report2 {
140 		content := reports.Report1(pdo, 1)
141 		outputReport(pclc.stdout, content, "report1.md")
142 		if pclc.report2 {
143 			content = genHTMLfromMarkdown()
144 			outputReport(pclc.stdout, content, "report2.html")
145 		}
146 	}
147 }
148 
149 //345678901234567890123456789012345678901234567890123456789012345678901234567890
150 // End of docsrc.go
151 
---snip---

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/branches


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/hooks


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/info


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/logs


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/logs/refs


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/logs/refs/heads


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/logs/refs/remotes


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/logs/refs/remotes/origin


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/01


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/05


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/15


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/17


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/1c


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/1d


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/23


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/30


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/38


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/49


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/51


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/5d


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/60


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/61


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/7d


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/81


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/87


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/88


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/90


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/93


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/94


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/99


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/a5


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/a8


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/ad


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/b3


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/b5


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/b9


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/be


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/c3


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/c9


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/d1


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/d5


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/d6


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/e1


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/f2


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/fd


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/info


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/objects/pack


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/refs


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/refs/heads


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/refs/remotes


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/refs/remotes/origin


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/.git/refs/tags


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/reports


Go source file:  common.go:

1 //	report2.go
2 package reports
3 
4 import (
5 	"fmt"
6 	"strings"
7 )
8 
9 func genLineNoPage(cStr string) (oStr string) {
10 	la := strings.Split(cStr, "\n")
11 	l := 1
12 	oStr = ""
13 	for _, s := range la {
14 		oStr += fmt.Sprintf("%d %s\n", l, s)
15 		l += 1
16 	}
17 	return
18 }
19 
20 // End of common.go
21 
---snip---

Go source file:  common_test.go:

1 package reports
2 
3 import (
4 	"os"
5 	"path/filepath"
6 	"regexp"
7 	"runtime"
8 	"testing"
9 	)
10 
11 const ( 
12 	neffs = "/tmp/nothingeverthere"
13 	)
14 
15 var pwd string
16 var thisfs string
17 var thisfiledir string
18 
19 // Subroutine Functions first in alphabetical order:
20 
21 // Initialize runtime parameters for the tests.
22 func init() {
23 	pwd = os.Getenv("PWD")
24 //RefNote:     Call to runtime.Caller(0) gets the name of this source file spec.
25 	_, thisfs, _, _ = runtime.Caller(0)
26 	thisfiledir = filepath.Dir(thisfs)
27 }
28 
29 func TestPrivate_genLineNoPage(t *testing.T) {
30 	content := genDirHdr(neffs)
31 	content = genLineNoPage(content)
32 	if len(content) == 0 {
33 		t.Errorf("genLineNoPage(genDirHdr(%s)) has no string content.",neffs)
34 	}
35 	if !regexp.MustCompile(`^\d+`).MatchString(content) {
36 		t.Errorf("genLineNoPage(genDirHdr(%s)) does not generate number prefixed lines.",neffs)
37 	}
38 }
39 
40 func TestThisfile(t *testing.T) {
41 	if len(pwd) == 0 {
42 		t.Errorf("pwd has no string content.")
43 	}
44 	if len(thisfs) == 0 {
45 		t.Errorf("thisfs has no string content.")
46 	}
47 	if len(thisfiledir) == 0 {
48 		t.Errorf("thisfiledir has no string content.")
49 	}
50 }
51 
52 
---snip---

Go source file:  report0.go:

1 //	report0.go
2 package reports
3 
4 import (
5 	"docsrc/treeseers"
6 	"fmt"
7 	"sort"
8 	"strings"
9 )
10 
11 const rptwidth = 132
12 
13 func genDirHdr(dSpec string) (content string) {
14 	content = genTxtHR("^")
15 	content += "\nSource Directory:  " + dSpec + "\n\n"
16 	return
17 }
18 
19 func genFileListings(fList treeseers.FileList) (content string) {
20 	fks := fList.NewKeySlice()
21 	sort.Strings(fks)
22 	content = "\n"
23 	for _, k := range fks {
24 		content += "Go source file:  " + k + ":\n\n"
25 		content += genLineNoPage(fList[k].Srccode)
26 		content += "---snip---\n\n"
27 	}
28 	return
29 }
30 
31 func genPkgList(dO *treeseers.DirObject) (content string) {
32 	filecount := dO.CountGoFiles()
33 	pkgcounts := make(treeseers.PkgCounts)
34 	dO.CountPkgs(pkgcounts)
35 	uniquepkgs := pkgcounts.NewKeySlice()
36 	sort.Strings(uniquepkgs)
37 	content += "Package counts:\n"
38 	for _, v := range uniquepkgs {
39 		content += fmt.Sprintf("%s: %d\n", v, pkgcounts[v])
40 	}
41 	content += fmt.Sprintf("Total Packages: %d\n", len(uniquepkgs))
42 	content += fmt.Sprintf("Total Go Source Files: %d\n", filecount)
43 	content += genTxtHR(".")
44 	return
45 }
46 
47 func genTxtHR(charStr string) string {
48 	content := strings.Repeat(charStr, rptwidth)
49 	content += "\n"
50 	return content
51 }
52 
53 func Report0(dO *treeseers.DirObject, dLevel int) (content string) {
54 //RefNote: Fspec is the directory spec for the Directory object:
55 	content = genDirHdr(dO.Fspec)
56 	content += genFileListings(dO.Flist)
57 	content += genTxtHR("~")
58 	dks := dO.Dtree.NewKeySlice()
59 	sort.Strings(dks)
60 	for _, k := range dks {
61 		content += Report0(dO.Dtree[k], dLevel+1)
62 	}
63 	if dLevel == 1 {
64 		content += genPkgList(dO)
65 	}
66 	return
67 }
68 
69 // End of report0.go
70 
---snip---

Go source file:  report0_test.go:

1 package reports
2 
3 import (
4 	"docsrc/treeseers"
5 	"fmt"
6 	"regexp"
7 	"testing"
8 	)
9 
10 func TestPrivate_genDirHdr(t *testing.T) {
11 	content := genDirHdr(neffs)
12 	if len(content) == 0 {
13 		t.Errorf("genDirHdr(%s) has no string content.",neffs)
14 	}
15 }
16 
17 func TestPrivate_genFileListings(t *testing.T) {
18 	tpdo := treeseers.SeqLoadDirObject(thisfiledir)
19 	content := genFileListings(tpdo.Flist)
20 	if (len(content) == 0) {
21 		t.Errorf("genFileListings(dO.Flist) generated no string content.")
22 	}
23 }
24 
25 func TestPrivate_genPkgList(t *testing.T) {
26 	tpdo := treeseers.SeqLoadDirObject(thisfiledir)
27 	content := genPkgList(tpdo)
28 	if (len(content) == 0) {
29 		t.Errorf("genPkgList(dO) generated no string content.")
30 	}
31 }
32 
33 func TestPrivate_genTxtHR(t *testing.T) {
34 	char := "."
35 	content := genTxtHR(char)
36 	rs := fmt.Sprintf("\\%s{%d}",char,rptwidth)
37 	if !regexp.MustCompile(rs).MatchString(content) {
38 		t.Errorf("genLineNoPage(\"%c\") does not generate %d column horizontal line of character %c.",char,rptwidth,char)
39 	}
40 }
41 
42 func TestReport0(t *testing.T) {
43 	tpdo := treeseers.SeqLoadDirObject(thisfiledir)
44 	content := Report0(tpdo,0)
45 	if (len(content) == 0) {
46 		t.Errorf("ReportO(%s) generated no string content.",thisfiledir)
47 	}
48 }
49 
---snip---

Go source file:  report1.go:

1 //	report1 - generate detailed markdown document for golang
2 //	source tree.
3 package reports
4 
5 import (
6 	"docsrc/treeseers"
7 	"fmt"
8 	"sort"
9 	"strings"
10 )
11 
12 func genMDLevelHdrPrefix(lNo int) string {
13 	mdhdrprefix := "######"
14 	if lNo < 6 {
15 		mdhdrprefix = strings.Repeat("#", lNo)
16 	}
17 	return mdhdrprefix + " "
18 }
19 
20 func genMDDirHdr(dLevel int, dSpec string) (content string) {
21 	hdrprefix := genMDLevelHdrPrefix(dLevel)
22 	content = fmt.Sprintf("\n%sSource Directory (level %d):\n",hdrprefix,dLevel)
23 	content += "\n`" + dSpec + "`\n"
24 	content += "\n" + hdrprefix + "Directory Description\n\n"
25 	return
26 }
27 
28 func genMDFileListings(dLevel int, fList treeseers.FileList,dSpec string) (content string) {
29 	hdrprefix := genMDLevelHdrPrefix(dLevel)
30 	fks := fList.NewKeySlice()
31 	sort.Strings(fks)
32 	content = "\n"
33 	for _, k := range fks {
34 		content += fmt.Sprintf("%sGo source file %s\n\n",hdrprefix,k)
35 		content += fmt.Sprintf("Full level %d filespec:  %s/%s)\n\n",dLevel,dSpec,k)
36 		content += "```\n"
37 		content += genLineNoPage(fList[k].Srccode)
38 		content += "---snip---\n"
39 		content += "```\n\n"
40 	}
41 	content += fmt.Sprintf("End of level %d source files in %s\n\n",dLevel,dSpec)
42 	return
43 }
44 
45 func genMDDirEndings(dLevel int, dO *treeseers.DirObject) (content string) {
46 	content = ""
47 	if dLevel == 1 {
48 		filecount := dO.CountGoFiles()
49 		pkgcounts := make(treeseers.PkgCounts)
50 		dO.CountPkgs(pkgcounts)
51 		uniquepkgs := pkgcounts.NewKeySlice()
52 		sort.Strings(uniquepkgs)
53 		content += "# Package Counts:\n"
54 		for _, v := range uniquepkgs {
55 			content += fmt.Sprintf("- %s: %d\n", v, pkgcounts[v])
56 		}
57 		content += fmt.Sprintf("- Total Packages: %d\n", len(uniquepkgs))
58 		content += fmt.Sprintf("- Total Go Source Files: %d\n", filecount)
59 	}
60 
61 	hdrprefix := genMDLevelHdrPrefix(dLevel)
62 	content += "\n" + hdrprefix + "Directory Notes for:\n"
63 	content += "`" + dO.Fspec + "`\n\n"
64 	content += dO.Notes
65 	content += fmt.Sprintf("\n%sEnding for %s, Level %d\n\n",hdrprefix,dO.Fspec,dLevel)
66 	return
67 }
68 
69 func Report1(dO *treeseers.DirObject, dLevel int) (content string) {
70 //RefNote: Fspec is the directory spec for the Directory object:
71 	content = genMDDirHdr(dLevel, dO.Fspec)
72 	content += dO.Description
73 	content += genMDFileListings(dLevel,dO.Flist,dO.Fspec)
74 	dks := dO.Dtree.NewKeySlice()
75 	sort.Strings(dks)
76 	for _, k := range dks {
77 		content += Report1(dO.Dtree[k], dLevel+1)
78 	}
79 	content += genMDDirEndings(dLevel, dO)
80 	return
81 }
82 
83 // End of report1.go
84 
---snip---

Go source file:  report1_test.go:

1 package reports
2 
3 import (
4 	"docsrc/treeseers"
5 	"fmt"
6 	"regexp"
7 	"testing"
8 	)
9 
10 func TestPrivate_genMDLevelHdrPrefix(t *testing.T) {
11 	for l := 1; l <= 6; l++ {
12 		content := genMDLevelHdrPrefix(l)
13 		rs := fmt.Sprintf("^#{%d} $",l)
14 		if !regexp.MustCompile(rs).MatchString(content) {
15 			t.Errorf("genMDLevelHdrPrefix(%d) generates incorrect markdown header prefix '%s'.",l,content)
16 		}
17 	}
18 }
19 
20 func TestPrivate_genMDDirHdr(t *testing.T) {
21 	content := genMDDirHdr(2, pwd)
22 //var pkgNamePatt *regexp.Regexp = regexp.MustCompile(`(?m:^\s*package\s+(\w+)\s*$)`)
23 	x := `## Source Directory \(level 2\):`
24 	if !regexp.MustCompile(x).MatchString(content) {
25 		t.Errorf("genMDDirHdr(2,%s) generates incorrect primary markdown heading.\n",pwd)
26 		fmt.Print(content)
27 		fmt.Println(x)
28 	}
29 	if !regexp.MustCompile(pwd).MatchString(content) {
30 		t.Errorf("genMDDirHdr(2,%s) generates header missing directory spec:  '%s'.\n",pwd,pwd)
31 	}
32 	x = `## Directory Description`
33 	if !regexp.MustCompile(x).MatchString(content) {
34 		t.Errorf("genMDDirHdr(2,%s) generates incorrect description markdown heading.\n",pwd)
35 		fmt.Print(content)
36 		fmt.Println(x)
37 	}
38 }
39 
40 func TestPrivate_genMDDirEndings(t *testing.T) {
41 	pdo := treeseers.SeqLoadDirObject(pwd)
42 	content := genMDDirEndings(1, pdo)
43 	x := `# Package Counts:`
44 	if !regexp.MustCompile(x).MatchString(content) {
45 		t.Errorf("genMDDirHdr(2,%s) generates incorrect primary markdown heading.\n",pwd)
46 		fmt.Print(content)
47 		fmt.Println(x)
48 	}
49 	if !regexp.MustCompile(pwd).MatchString(content) {
50 		t.Errorf("genMDDirHdr(2,%s) generates header missing directory spec:  '%s'.\n",pwd,pwd)
51 	}
52 	x = `# Ending for \S+, Level 1`
53 	if !regexp.MustCompile(x).MatchString(content) {
54 		t.Errorf("genMDDirHdr(2,%s) generates incorrect primary markdown heading.\n",pwd)
55 		fmt.Print(content)
56 		fmt.Println(x)
57 	}
58 }
59 
60 func TestReport1(t *testing.T) {
61 	pdo := treeseers.SeqLoadDirObject(pwd)
62 	content := Report1(pdo, 1)
63 	if len(content) == 0 {
64 		t.Errorf("Report1(%s,pdo,1) yields no content.",pwd)
65 	}
66 }
67 
68 // report1_test.go
69 
---snip---

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Source Directory:  /home/xeno/shop/go/src/docsrc/treeseers


Go source file:  common.go:

1 //  Common routines for use by members and clients of treeseers package.
2 
3 // Tree Seer is simply a mild mannered parsing package for use by docsrc for
4 // gathering custom source tree items of interest into a common reference, which
5 // starts with the DirObject defined below.  This object holds a tree subset of
6 // the source tree data for passing to the selected report packages.
7 //
8 //RefNote:  Note that these resources are automatically seen by all other go
9 //programming in this package directory.
10 package treeseers
11 //345678901234567890123456789012345678901234567890123456789012345678901234567890
12 
13 import (
14 	"fmt"
15 	"io/ioutil"
16 	"os"
17 	"regexp"
18 	"strings"
19 )
20 
21 const noPkgNameName ="<No Package Name Found In Source File>"
22 
23 // Common objects are things that will be used in reporting for both files and
24 // directories.
25 type CommonObject struct {
26 	Fspec		string
27 	Description	string
28 	Notes		string 
29 }
30 
31 // DirObject represents the directory tree from the starting point.
32 type DirObject struct {
33 	CommonObject
34 	README	string 
35 	Dtree	DirTree
36 	Flist	FileList
37 }
38 
39 // FileObject represents items of reporting interest for the specified source file.
40 type FileObject struct {
41 	CommonObject
42 	Pkgname	string
43 	Srccode	string
44 }
45 
46 type DirTree map[string]*DirObject
47 type FileList map[string]*FileObject
48 type PkgCounts map[string]int
49 
50 // Regular expression to match a go source file, which is to say something like:
51 // "common.go", "docsrc.go" or "common_test.go".
52 var goSrcFlPatt *regexp.Regexp = regexp.MustCompile(`^[A-Za-z0-9_]+\.go$`)
53 
54 // Regular expression presuming single line mode works well over multi-line
55 // string.
56 var pkgNamePatt *regexp.Regexp = regexp.MustCompile(`(?m:^\s*package\s+(\w+)\s*$)`)
57 
58 //345678901234567890123456789012345678901234567890123456789012345678901234567890
59 // Begin functions (I use 80 column terminals, so the rule is just for me: Xeno)
60 
61 // GetContentIfExists simply provides a string with file content if that file
62 // is found where specified, and otherwise returns a zero length string.  This
63 // allows variable reporting on source files and directories as the maintainer
64 // sees fit or otherwise finds convenient.  It also accommodates incremental
65 // building of an application and the writing of it's documentation.
66 func GetContentIfExists(fSpec string) string {
67 	bytes, err := ioutil.ReadFile(fSpec)
68 	// Note that in the case of errors in this file, returning
69 	// nil is not a signal of error, but just legitimate data
70 	// for passing to the reporter.  The whole idea here is to
71 	// not care if you just don't get the file.
72 	if os.IsNotExist(err) {
73 		return ""
74 	}
75 	if err != nil {
76 		fmt.Errorf("Unexpected Error reading %v, %q.(%v)",err,fSpec,os.IsNotExist(err))
77 		return ""
78 	}
79 	return string(bytes)
80 }
81 
82 // Count the total .go files referenced in the DirObject tree.
83 func (dO *DirObject) CountGoFiles() (count int) {
84 	count = len(dO.Flist)
85 	for _, ldo := range dO.Dtree {
86 		count += ldo.CountGoFiles()
87 	}
88 	return
89 }
90 
91 // Count the total .go files for each package referenced in the DirObject tree.
92 func (dO *DirObject) CountPkgs(pkgCounts PkgCounts) {
93 	for _, v := range dO.Flist {
94 		if _, ok := pkgCounts[v.Pkgname]; ok {
95 			pkgCounts[v.Pkgname] += 1
96 		} else {
97 			pkgCounts[v.Pkgname] = 1
98 		}
99 	}
100 	for _, ldo := range dO.Dtree {
101 		ldo.CountPkgs(pkgCounts)
102 	}
103 }
104 
105 // GetPkgNameFromStr takes a string from a presumed Golang source file and
106 // returns the package name listed first in the file.
107 func GetPkgNameFromStr(srcStr string) string {
108 	xa := pkgNamePatt.FindStringSubmatch(srcStr)
109 	if len(xa) > 1 {
110 		return xa[1]
111 	}
112 	return noPkgNameName
113 }
114 
115 // IsGoSrcFile is a boolean (bool) returning function for use in places where
116 // reporting must decide to use files iff they are such source files.
117 func IsGoSrcFile(fSpec string) (bool) {
118 	if len(fSpec) < 4 { // Because the smallest size is like "a.go".
119 		return false
120 	}
121 	if goSrcFlPatt.MatchString(fSpec) {
122 		return true
123 	}
124 	ra := strings.Split(fSpec,"/") // For the case of a filespec or URL.
125 	lra := len(ra)
126 	if lra > 0 {
127 		if goSrcFlPatt.MatchString(ra[lra-1]) {
128 			return true
129 		} 
130 	}
131 	return false
132 }
133 
134 // Load the FileObject data.
135 func LoadFileObject(fSpec string) (psfo *FileObject) {
136 	psfo = &FileObject{CommonObject: CommonObject{Fspec: fSpec}}
137 	scbytes, err := ioutil.ReadFile(fSpec)
138 	if err != nil {
139 		fmt.Printf("Error reading file %s %v(%v)\n",fSpec,err)
140 		// But continue anyway
141 	} else {
142 		psfo.Srccode = string(scbytes)
143 		psfo.Pkgname = GetPkgNameFromStr(psfo.Srccode)
144 	}
145 
146 	fsprefix := strings.TrimSuffix(fSpec,".go")
147 	psfo.Description = GetContentIfExists(fsprefix + "_description.md")
148 	psfo.Notes = GetContentIfExists(fsprefix + "_notes.md")
149 	return
150 }
151 
152 // Create a new DirObject struct.
153 func NewDirObject(dSpec string) (pdo *DirObject) {
154 	pdo = &DirObject{CommonObject: CommonObject{Fspec: dSpec}}
155 
156 	pdo.Description = GetContentIfExists(dSpec + "/Directory_description.md")
157 	pdo.Notes = GetContentIfExists(dSpec + "/Directory_notes.md")
158 	pdo.README = GetContentIfExists(dSpec + "/README.md")
159 	return
160 }
161 
162 // Generate a slice of keys for a Directory Tree map.
163 func (dTree *DirTree) NewKeySlice() (keyslice []string) {
164 	l := len(*dTree) 
165 	keyslice = make([]string,l,l)
166 	i := 0
167 	for k, _ := range *dTree {
168 		keyslice[i] = k
169 		i += 1
170 	}
171 	return
172 }
173 
174 // Generate a slice of keys for a File List map.
175 func (fList *FileList) NewKeySlice() (keyslice []string) {
176 	l := len(*fList) 
177 	keyslice = make([]string,l,l)
178 	i := 0
179 	for k, _ := range *fList {
180 		keyslice[i] = k
181 		i += 1
182 	}
183 	return
184 }
185 
186 // Generate a slice of keys for a Package Counts map.
187 func (pkgCounts PkgCounts) NewKeySlice() (keyslice []string) {
188 	l := len(pkgCounts) 
189 	keyslice = make([]string,l,l)
190 	i := 0
191 	for k, _ := range pkgCounts {
192 		keyslice[i] = k
193 		i += 1
194 	}
195 	return
196 }
197 
198 // End of common.go (because Xeno likes to put that here anyway)5678901234567890
199 
---snip---

Go source file:  common_test.go:

1 // Test functions for use across treeseer package, or by other tests.
2 package treeseers
3 //345678901234567890123456789012345678901234567890123456789012345678901234567890
4 
5 import ( 
6 		"path/filepath"
7 		"io/ioutil"
8 		"runtime"
9 		"testing"
10 	)
11 
12 const ( 
13 	neffs = "/tmp/nothingeverthere"
14 	)
15 
16 var thisfs string
17 
18 // Subroutine Functions first in alphabetical order:
19 
20 // Initialize runtime parameters for the tests.
21 func init() {
22 //RefNote:     Call to runtime.Caller(0) gets the name of this source file spec.
23 	_, thisfs, _, _ = runtime.Caller(0)
24 }
25 
26 func tpField(t *testing.T, mUT string, fN string, fL int, zV bool) {
27 	if zV {
28 		if fL != 0 {
29 			t.Errorf("Fail %s length for %s(%s) = \"%v\", want zero.",fN,mUT,fL)
30 		}
31 	} else {
32 		if fL == 0 {
33 			t.Errorf("Fail %s length for %s(%s) = zero, want non-zero.",fN,mUT)
34 		}
35 	}
36 }
37 
38 func tst1LoadDirObject(t *testing.T,tL string,tO *DirObject) {
39 	tpField(t,"LoadDirObject","Description",len(tO.Description),true)
40 	tpField(t,"LoadDirObject","Notes",len(tO.Notes),true)
41 	tpField(t,"LoadDirObject","README",len(tO.README),true)
42 	tpField(t,"LoadDirObject","Dtree",len(tO.Dtree),true)
43 	tpField(t,"LoadDirObject","Flist",len(tO.Flist),true)
44 }
45 
46 func tst2LoadDirObject(t *testing.T,tL string,tO *DirObject) {
47 	tpField(t,"LoadDirObject","Description",len(tO.Description),false)
48 	tpField(t,"LoadDirObject","Notes",len(tO.Notes),false)
49 	tpField(t,"LoadDirObject","README",len(tO.README),false)
50 	tpField(t,"LoadDirObject","Dtree",len(tO.Dtree),true)
51 	tpField(t,"LoadDirObject","Flist",len(tO.Flist),false)
52 }
53 
54 // Actual Tests Last, in alphabetical order:
55 
56 func TestCountGoFiles(t *testing.T) {
57 	tpdo := NewDirObject(neffs)
58 	count := tpdo.CountGoFiles()
59 	if count != 0 {
60 		t.Errorf("TestCountGoFiles: FAIL count test should be 0, was %d.\n",count)
61 	}
62 	tpdo.Flist = make(FileList)
63 	tpdo.Flist["fakefile.go"] = new(FileObject)
64 	tpdo.Flist["fakefile.go"].Pkgname = "fakepackage"
65 	tpdo.Flist["fakefile.go"].Srccode = "fakesource"
66 	count = tpdo.CountGoFiles()
67 	if count != 1 {
68 		t.Errorf("TestCountGoFiles: FAIL count test should be 1, was %d.\n",count)
69 	}
70 }
71 
72 func TestCountPkgs(t *testing.T) {
73 	tpdo := NewDirObject(neffs)
74 	pkgcounts := make(PkgCounts)
75 	tpdo.CountPkgs(pkgcounts)
76 	l := len(pkgcounts)
77 	if l != 0 {
78 		t.Errorf("TestCountPkgs: FAIL package count test should be 0, was %d.\n",l)
79 	}
80 	tpdo.Flist = make(FileList)
81 	tpdo.Flist["fakefile.go"] = new(FileObject)
82 	tpdo.Flist["fakefile.go"].Pkgname = "fakepackage"
83 	tpdo.Flist["fakefile.go"].Srccode = "fakesource"
84 	pkgcounts2 := make(PkgCounts)
85 	tpdo.CountPkgs(pkgcounts2)
86 	l = len(pkgcounts2)
87 	if l != 1 {
88 		t.Errorf("TestCountPkgs: FAIL package count test should be 1, was %d.\n",l)
89 	}
90 	for _, v := range pkgcounts {
91 		if v != 1 {
92 			t.Errorf("TestCountPkgs: FAIL package count test must be 1 or more, was %d.\n",v)
93 		}
94 	}
95 }
96 
97 func TestGetContentIfExists(t *testing.T) {
98 	result := GetContentIfExists(neffs)
99 	if result != "" {
100 		t.Errorf("TestGetContentIfExists: FAIL reading nonexistent file %s (%v)\n",neffs,result)
101 	}
102 	result = GetContentIfExists(thisfs)
103 	if len(result) <= 0 {
104 		t.Errorf("TestGetContentIfExists: FAIL reading file %s (%v)\n",thisfs,result)
105 	}
106 }
107 
108 func TestGetPkgNameFromStr(t *testing.T) {
109 	scbytes, err := ioutil.ReadFile(thisfs)
110 	if err != nil {
111 		t.Errorf("TestGetPkgNameFromStr: Error reading file %s (%v)\n",thisfs,err)
112 		// But continue anyway
113 	}
114 	sourcecode := string(scbytes)
115 	pkgname := GetPkgNameFromStr(sourcecode)
116 	if pkgname != "treeseers" {
117 		t.Errorf("GetPkgNameFromStr({this source file contents}) = \"%v\", want \"treeseers\"",pkgname)
118 	} 
119 
120 	pkgname = GetPkgNameFromStr("No code here.")
121 	if pkgname != noPkgNameName {
122 		t.Errorf("GetPkgNameFromStr(\"No code here.\") = \"%v\", want \"%v\"",pkgname,noPkgNameName)
123 	} 
124 
125 	pkgname = GetPkgNameFromStr("")
126 	if pkgname != noPkgNameName {
127 		t.Errorf("GetPkgNameFromStr(\"\") = \"%v\", want \"%v\"",pkgname,noPkgNameName)
128 	} 
129 }
130 
131 func TestIsGoSrcFile(t *testing.T) {
132 	for _, v := range []string{"myreallylongsourcefilenamethatissolongyoudontwannareadit.go","b.go"} {
133 		if !IsGoSrcFile(v) {
134 			t.Errorf("IsGoSrcFile(\"%s\") == false, want true.",v)
135 		}
136 	}
137 	for _, v := range []string{"myreallylongsourcefilenamethatissolongyoudontwannareadit.goesaway","b.g",".go","bgo"} {
138 		if IsGoSrcFile(v) {
139 			t.Errorf("IsGoSrcFile(\"%s\") == true, want false.",v)
140 		}
141 	}
142 }
143 
144 func TestLoadFileObject(t *testing.T) {
145 	tpfo := LoadFileObject(neffs)
146 	tpField(t,"LoadFileObject","Description",len(tpfo.Description),true)
147 	tpField(t,"LoadFileObject","Notes",len(tpfo.Notes),true)
148 	tpField(t,"LoadFileObject","Pkgname",len(tpfo.Pkgname),true)
149 	tpField(t,"LoadFileObject","Srccode",len(tpfo.Srccode),true)
150 	tpfo = LoadFileObject(thisfs)
151 	tpField(t,"LoadFileObject","Description",len(tpfo.Description),false)
152 	tpField(t,"LoadFileObject","Notes",len(tpfo.Notes),false)
153 	tpField(t,"LoadFileObject","Pkgname",len(tpfo.Pkgname),false)
154 	tpField(t,"LoadFileObject","Srccode",len(tpfo.Srccode),false)
155 }
156 
157 func TestNewDirObject(t *testing.T) {
158 	tpdo := NewDirObject(neffs)
159 	tpField(t,"NewDirObject","Description",len(tpdo.Description),true)
160 	tpField(t,"NewDirObject","Notes",len(tpdo.Notes),true)
161 	tpField(t,"NewDirObject","README",len(tpdo.README),true)
162 	tpField(t,"NewDirObject","Dtree",len(tpdo.Dtree),true)
163 	tpField(t,"NewDirObject","Flist",len(tpdo.Flist),true)
164 	thisfiledir := filepath.Dir(thisfs)
165 	tpdo = NewDirObject(thisfiledir)
166 	tpField(t,"NewDirObject","Description",len(tpdo.Description),false)
167 	tpField(t,"NewDirObject","Notes",len(tpdo.Notes),false)
168 	tpField(t,"NewDirObject","README",len(tpdo.README),false)
169 	tpField(t,"NewDirObject","Dtree",len(tpdo.Dtree),true)
170 	tpField(t,"NewDirObject","Flist",len(tpdo.Flist),true)
171 }
172 
173 func TestNewKeySlice(t *testing.T) {
174 
175 	// on DirTree map type.
176 
177 	dtree := make(DirTree)
178 	ks := dtree.NewKeySlice()
179 	l := len(ks)
180 	if l != 0 {
181 		t.Errorf("dtree.NewKeySlice() has slice length %d, want 0.",l)
182 	}
183 	dtree = make(DirTree)
184 	dtree["fakedir"] = new(DirObject)
185 	dtree["fakedir2"] = new(DirObject)
186 	ks = dtree.NewKeySlice()
187 	l = len(ks)
188 	if l != 2 {
189 		t.Errorf("dtree.NewKeySlice() has slice length %d, want 2.",l)
190 	}
191 
192 	// on FileList map type.
193 
194 	flist := make(FileList)
195 	ks = flist.NewKeySlice()
196 	l = len(ks)
197 	if l != 0 {
198 		t.Errorf("flist.NewKeySlice() has slice length %d, want 0.",l)
199 	}
200 	flist = make(FileList)
201 	flist["fakefile.go"] = new(FileObject)
202 	flist["fakefile.go"].Pkgname = "fakepackage"
203 	flist["fakefile.go"].Srccode = "fakesource"
204 	ks = flist.NewKeySlice()
205 	l = len(ks)
206 	if l != 1 {
207 		t.Errorf("flist.NewKeySlice() has slice length %d, want 1.",l)
208 	}
209 
210 	// on PkgCounts map type.
211 
212 	pkgcounts := make(PkgCounts)
213 	ks = pkgcounts.NewKeySlice()
214 	l = len(ks)
215 	if l != 0 {
216 		t.Errorf("pkgcounts.NewKeySlice() has slice length %d, want 0.",l)
217 	}
218 	pkgcounts = make(PkgCounts)
219 	pkgcounts["fakepkg1"] = 1
220 	pkgcounts["fakepkg2"] = 2
221 	pkgcounts["fakepkg3"] = 3
222 	ks = pkgcounts.NewKeySlice()
223 	l = len(ks)
224 	if l != 3 {
225 		t.Errorf("pkgcounts.NewKeySlice() has slice length %d, want 3.",l)
226 	}
227 
228 }
229 
230 // End of common_test.go
231 
---snip---

Go source file:  concurrent.go:

1 package treeseers
2 //345678901234567890123456789012345678901234567890123456789012345678901234567890
3 
4 import (
5 	"fmt"
6 	"io/ioutil"
7 )
8 
9 type KVPair struct {
10 	dkey	string
11 	dobj	*DirObject
12 }
13 
14 func ConLoadDirObject(dSpec string) (pdo *DirObject) {
15 	pdo = NewDirObject(dSpec)
16 
17 	l, err :=	ioutil.ReadDir(dSpec)
18 	if err != nil {
19 		fmt.Printf("Error reading directory %s (%v)\n",dSpec,err)
20 		// But continue anyway
21 	} else {
22 		c := make(chan *KVPair, 5)
23 		tdc := 0
24 		for _, f := range l {
25 			fn := f.Name()
26 			fs := dSpec + "/" + fn
27 			if f.IsDir() {
28 				if pdo.Dtree == nil {
29 					pdo.Dtree = make(DirTree)
30 				}
31 				go func (kvpCh chan *KVPair, fN, fS string) {
32 						lkvp := KVPair{dkey: fN}
33 						lkvp.dobj = ConLoadDirObject(fS)
34 						kvpCh <- &lkvp
35 					}(c,fn,fs)
36 				tdc += 1
37 			} else {
38 				if pdo.Flist == nil {
39 					pdo.Flist = make(map[string]*FileObject)
40 				}
41 				if IsGoSrcFile(fn) {
42 					pdo.Flist[fn] = LoadFileObject(fs)
43 				}
44 			}
45 		}
46 		var kvp *KVPair
47 		for j := tdc;  j > 0;  j-- {
48 			kvp = <- c;
49 			pdo.Dtree[kvp.dkey] = kvp.dobj
50 		}
51 	}
52 	return
53 }
54 
---snip---

Go source file:  concurrent_test.go:

1 // Test concurrent version of LoadDirObject Method
2 package treeseers
3 
4 import ( 
5 		"path/filepath"
6 		"runtime"
7 		"testing"
8 	)
9 
10 // Subroutine Functions first in alphabetical order:
11 
12 // Initialize runtime parameters for the tests.
13 func init() {
14 //RefNote:     Call to runtime.Caller(0) gets the name of this source file spec.
15 	_, thisfs, _, _ = runtime.Caller(0)
16 }
17 
18 func TestConLoadDirObject(t *testing.T) {
19 	tpdo := ConLoadDirObject(neffs)
20 	tst1LoadDirObject(t,"ConLoadDirObject",tpdo)
21 	_, thisfs, _, _ := runtime.Caller(0)
22 	thisfiledir := filepath.Dir(thisfs)
23 	tpdo = ConLoadDirObject(thisfiledir)
24 	tst2LoadDirObject(t,"ConLoadDirObject",tpdo)
25 }
26 
27 // End of concurrent_test.go
28 
---snip---

Go source file:  sequential.go:

1 package treeseers
2 //345678901234567890123456789012345678901234567890123456789012345678901234567890
3 
4 import (
5 	"fmt"
6 	"io/ioutil"
7 )
8 
9 func SeqLoadDirObject(dSpec string) (pdo *DirObject) {
10 	pdo = NewDirObject(dSpec)
11 
12 	l, err :=	ioutil.ReadDir(dSpec)
13 	if err != nil {
14 		fmt.Printf("Error reading directory %s (%v)\n",dSpec,err)
15 		// But continue anyway
16 	} else {
17 		for _, f := range l {
18 			fn := f.Name()
19 			fs := dSpec + "/" + fn
20 			if f.IsDir() {
21 				if pdo.Dtree == nil {
22 					pdo.Dtree = make(map[string]*DirObject)
23 				}
24 				pdo.Dtree[fn] = SeqLoadDirObject(fs)
25 			} else {
26 				if pdo.Flist == nil {
27 					pdo.Flist = make(map[string]*FileObject)
28 				}
29 				if IsGoSrcFile(fn) {
30 					pdo.Flist[fn] = LoadFileObject(fs)
31 				}
32 			}
33 		}
34 	}
35 	return
36 }
37 
---snip---

Go source file:  sequential_test.go:

1 // Test sequential version of LoadDirObject Method
2 package treeseers
3 
4 import ( 
5 		"path/filepath"
6 		"runtime"
7 		"testing"
8 	)
9 
10 // Subroutine Functions first in alphabetical order:
11 
12 // Initialize runtime parameters for the tests.
13 func init() {
14 //RefNote:     Call to runtime.Caller(0) gets the name of this source file spec.
15 	_, thisfs, _, _ = runtime.Caller(0)
16 }
17 
18 
19 func TestSeqLoadDirObject(t *testing.T) {
20 	tpdo := SeqLoadDirObject(neffs)
21 	tst1LoadDirObject(t,"SeqLoadDirObject",tpdo)
22 	_, thisfs, _, _ := runtime.Caller(0)
23 	thisfiledir := filepath.Dir(thisfs)
24 	tpdo = SeqLoadDirObject(thisfiledir)
25 	tst2LoadDirObject(t,"SeqLoadDirObject",tpdo)
26 }
27 
28 // End of sequential_test.go
29 
---snip---

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Package counts:
main: 1
reports: 6
treeseers: 6
Total Packages: 3
Total Go Source Files: 13
....................................................................................................................................
